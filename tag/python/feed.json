{
    "version": "https://jsonfeed.org/version/1",
    "title": "Village • All posts by \"python\" tag",
    "description": "It is a little blog～",
    "home_page_url": "https://nanaeo.cn",
    "items": [
        {
            "id": "https://nanaeo.cn/2022/08/17/PythonDecorator/",
            "url": "https://nanaeo.cn/2022/08/17/PythonDecorator/",
            "title": "快速理解Py装饰器",
            "date_published": "2022-08-17T16:00:00.000Z",
            "content_html": "<p>一文理解Python装饰器</p>\n<span id=\"more\"></span>\n\n<div class=\"story post-story\"><h2 id=\"本文提示\"><a href=\"#本文提示\" class=\"headerlink\" title=\"本文提示\"></a>本文提示</h2><p>文章来自学习笔记,<strong>目前本文仍然在排版中</strong></p>\n</div><div class=\"story post-story\"><h2 id=\"概念快解\"><a href=\"#概念快解\" class=\"headerlink\" title=\"概念快解\"></a>概念快解</h2><h3 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h3><p>这是一种设计模式，它允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p>\n<h3 id=\"Python的装饰器\"><a href=\"#Python的装饰器\" class=\"headerlink\" title=\"Python的装饰器\"></a>Python的装饰器</h3><p>Python中的装饰器类似，在现有功能上进行添加功能并且不改变原代码结构。</p>\n</div><div class=\"story post-story\"><h2 id=\"前言故事\"><a href=\"#前言故事\" class=\"headerlink\" title=\"前言故事\"></a>前言故事</h2><p>最近在学习Python看到方法前面一行@开头代码(如下)很好奇</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@test</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">demo</span>()</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n<p>查阅资料后发现其实这是Python装饰器，类似的设计模式称为装饰器模式。</p>\n</div><div class=\"story post-story\"><h2 id=\"一切皆是对象\"><a href=\"#一切皆是对象\" class=\"headerlink\" title=\"一切皆是对象\"></a>一切皆是对象</h2><p>先别急，我们先理解一个概念，我们在Python可以将一切东西理解为对象，就像Linux一切皆文件的思想。甚至是一个函数其实也是对象</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">b</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;hi&quot;</span>)</span><br><span class=\"line\">a = b</span><br><span class=\"line\">b()</span><br><span class=\"line\">a()</span><br><span class=\"line\"><span class=\"comment\"># 结果毫无疑问是两个hi a与b同时将指向同一个函数对象</span></span><br><span class=\"line\"><span class=\"comment\"># a() b() 产生的结果固然一样</span></span><br></pre></td></tr></table></figure>\n<p>那么根据以上我们可以知道函数也是可以作为参数进行传递<br>Python中的一切(是的，甚至是类)都是对象。 我们定义的名称只是绑定到这些对象的标识符。 函数也不例外，它们也是对象(带有属性)。 </p>\n</div><div class=\"story post-story\"><h2 id=\"将函数作为参数\"><a href=\"#将函数作为参数\" class=\"headerlink\" title=\"将函数作为参数\"></a>将函数作为参数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">a1</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">b1</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x - <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">operate</span>(<span class=\"params\">func, x</span>):</span><br><span class=\"line\">    result = func(x)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">operate(a1,<span class=\"number\">5</span>)</span><br><span class=\"line\">operate(b1,<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n<p>结果是10和0<br>相信熟悉PHP同学感觉很熟悉了，有类似的感觉了，该函数是一个高阶函数(将其他函数作为参数的函数也称为高阶函数)</p>\n</div><div class=\"story post-story\"><h2 id=\"尝试在函数返回另一个函数\"><a href=\"#尝试在函数返回另一个函数\" class=\"headerlink\" title=\"尝试在函数返回另一个函数\"></a>尝试在函数返回另一个函数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">hi</span>():</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">ret_p</span>():</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;HelloWorld&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret_p <span class=\"comment\"># 返回ret_p函数对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">ret_f = hi() <span class=\"comment\"># 获取ret_p函数对象</span></span><br><span class=\"line\">ret_f() <span class=\"comment\"># 执行ret_p函数</span></span><br></pre></td></tr></table></figure>\n<p>结果输出HelloWorld，那么这些都是非常简单的，就像新手入门一样。</p>\n</div><div class=\"story post-story\"><h2 id=\"回归装饰器\"><a href=\"#回归装饰器\" class=\"headerlink\" title=\"回归装饰器\"></a>回归装饰器</h2><p>细细观察以下代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">a</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">inner</span>():</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;decorated&quot;</span>)</span><br><span class=\"line\">        func()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inner</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">b</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;function&quot;</span>)</span><br><span class=\"line\">b()</span><br></pre></td></tr></table></figure>\n<p>我们发现这段代码这里输出结果是 function<br>但是我们稍加修改就会实现特殊功能</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">a</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">inner</span>():</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;decorated&quot;</span>)</span><br><span class=\"line\">        func()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inner</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">b</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;function&quot;</span>)</span><br><span class=\"line\">c = a(b)</span><br><span class=\"line\">c()</span><br></pre></td></tr></table></figure>\n<p>这样你就会发现结果是decorated和function，<br>b函数的结果并没有进行任何修改我们就实现了对功能增加<br>那么我们还可以稍加优化，去掉c直接将修饰好的函数覆盖原来的函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">a</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">inner</span>():</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;decorated&quot;</span>)</span><br><span class=\"line\">        func()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inner</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">b</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;function&quot;</span>)</span><br><span class=\"line\">b = a(b)</span><br><span class=\"line\">b()</span><br></pre></td></tr></table></figure>\n<p>我们可以发现如果将最后一行c改成b你就发现原b函数的功能被增加了，并且覆盖原功能了，这就Python基础修饰器<br>但是这和@那行实现的装饰器有什么区别呢，其实以下代码等价于以上代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">a</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">inner</span>():</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;decorated&quot;</span>)</span><br><span class=\"line\">        func()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inner</span><br><span class=\"line\"><span class=\"meta\">@a</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">b</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;function&quot;</span>)</span><br><span class=\"line\">b()</span><br></pre></td></tr></table></figure>\n<p>那么@a的功能代替了原本<code>b = a(b)</code>，对函数进行修饰。<br>那么这样我们就完成了一个最基本的修饰器</p>\n</div><div class=\"story post-story\"><h2 id=\"参数装饰函数\"><a href=\"#参数装饰函数\" class=\"headerlink\" title=\"参数装饰函数\"></a>参数装饰函数</h2><h2 id=\"待补充\"><a href=\"#待补充\" class=\"headerlink\" title=\"待补充\"></a>待补充</h2><h2 id=\"待排版\"><a href=\"#待排版\" class=\"headerlink\" title=\"待排版\"></a>待排版</h2><p>实际上，只要这个对象使用特殊方法实现了__call__()，那么这个对象就是可以被可调用。 </p>\n\n</div>",
            "tags": [
                "DevLog",
                "Python"
            ]
        }
    ]
}