{
    "version": "https://jsonfeed.org/version/1",
    "title": "Village • All posts by \"devlog\" category",
    "description": "It is a little blog～",
    "home_page_url": "https://nanaeo.cn",
    "items": [
        {
            "id": "https://nanaeo.cn/2022/08/17/PythonDecorator/",
            "url": "https://nanaeo.cn/2022/08/17/PythonDecorator/",
            "title": "快速理解Py装饰器",
            "date_published": "2022-08-17T16:00:00.000Z",
            "content_html": "<p>一文理解Python装饰器</p>\n<span id=\"more\"></span>\n\n<div class=\"story post-story\"><h2 id=\"本文提示\"><a href=\"#本文提示\" class=\"headerlink\" title=\"本文提示\"></a>本文提示</h2><p>文章来自学习笔记,<strong>目前本文仍然在排版中</strong></p>\n</div><div class=\"story post-story\"><h2 id=\"概念快解\"><a href=\"#概念快解\" class=\"headerlink\" title=\"概念快解\"></a>概念快解</h2><h3 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h3><p>这是一种设计模式，它允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p>\n<h3 id=\"Python的装饰器\"><a href=\"#Python的装饰器\" class=\"headerlink\" title=\"Python的装饰器\"></a>Python的装饰器</h3><p>Python中的装饰器类似，在现有功能上进行添加功能并且不改变原代码结构。</p>\n</div><div class=\"story post-story\"><h2 id=\"前言故事\"><a href=\"#前言故事\" class=\"headerlink\" title=\"前言故事\"></a>前言故事</h2><p>最近在学习Python看到方法前面一行@开头代码(如下)很好奇</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@test</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">demo</span>()</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n<p>查阅资料后发现其实这是Python装饰器，类似的设计模式称为装饰器模式。</p>\n</div><div class=\"story post-story\"><h2 id=\"一切皆是对象\"><a href=\"#一切皆是对象\" class=\"headerlink\" title=\"一切皆是对象\"></a>一切皆是对象</h2><p>先别急，我们先理解一个概念，我们在Python可以将一切东西理解为对象，就像Linux一切皆文件的思想。甚至是一个函数其实也是对象</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">b</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;hi&quot;</span>)</span><br><span class=\"line\">a = b</span><br><span class=\"line\">b()</span><br><span class=\"line\">a()</span><br><span class=\"line\"><span class=\"comment\"># 结果毫无疑问是两个hi a与b同时将指向同一个函数对象</span></span><br><span class=\"line\"><span class=\"comment\"># a() b() 产生的结果固然一样</span></span><br></pre></td></tr></table></figure>\n<p>那么根据以上我们可以知道函数也是可以作为参数进行传递<br>Python中的一切(是的，甚至是类)都是对象。 我们定义的名称只是绑定到这些对象的标识符。 函数也不例外，它们也是对象(带有属性)。 </p>\n</div><div class=\"story post-story\"><h2 id=\"将函数作为参数\"><a href=\"#将函数作为参数\" class=\"headerlink\" title=\"将函数作为参数\"></a>将函数作为参数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">a1</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">b1</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x - <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">operate</span>(<span class=\"params\">func, x</span>):</span><br><span class=\"line\">    result = func(x)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">operate(a1,<span class=\"number\">5</span>)</span><br><span class=\"line\">operate(b1,<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n<p>结果是10和0<br>相信熟悉PHP同学感觉很熟悉了，有类似的感觉了，该函数是一个高阶函数(将其他函数作为参数的函数也称为高阶函数)</p>\n</div><div class=\"story post-story\"><h2 id=\"尝试在函数返回另一个函数\"><a href=\"#尝试在函数返回另一个函数\" class=\"headerlink\" title=\"尝试在函数返回另一个函数\"></a>尝试在函数返回另一个函数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">hi</span>():</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">ret_p</span>():</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;HelloWorld&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret_p <span class=\"comment\"># 返回ret_p函数对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">ret_f = hi() <span class=\"comment\"># 获取ret_p函数对象</span></span><br><span class=\"line\">ret_f() <span class=\"comment\"># 执行ret_p函数</span></span><br></pre></td></tr></table></figure>\n<p>结果输出HelloWorld，那么这些都是非常简单的，就像新手入门一样。</p>\n</div><div class=\"story post-story\"><h2 id=\"回归装饰器\"><a href=\"#回归装饰器\" class=\"headerlink\" title=\"回归装饰器\"></a>回归装饰器</h2><p>细细观察以下代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">a</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">inner</span>():</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;decorated&quot;</span>)</span><br><span class=\"line\">        func()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inner</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">b</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;function&quot;</span>)</span><br><span class=\"line\">b()</span><br></pre></td></tr></table></figure>\n<p>我们发现这段代码这里输出结果是 function<br>但是我们稍加修改就会实现特殊功能</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">a</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">inner</span>():</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;decorated&quot;</span>)</span><br><span class=\"line\">        func()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inner</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">b</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;function&quot;</span>)</span><br><span class=\"line\">c = a(b)</span><br><span class=\"line\">c()</span><br></pre></td></tr></table></figure>\n<p>这样你就会发现结果是decorated和function，<br>b函数的结果并没有进行任何修改我们就实现了对功能增加<br>那么我们还可以稍加优化，去掉c直接将修饰好的函数覆盖原来的函数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">a</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">inner</span>():</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;decorated&quot;</span>)</span><br><span class=\"line\">        func()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inner</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">b</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;function&quot;</span>)</span><br><span class=\"line\">b = a(b)</span><br><span class=\"line\">b()</span><br></pre></td></tr></table></figure>\n<p>我们可以发现如果将最后一行c改成b你就发现原b函数的功能被增加了，并且覆盖原功能了，这就Python基础修饰器<br>但是这和@那行实现的装饰器有什么区别呢，其实以下代码等价于以上代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">a</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">inner</span>():</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;decorated&quot;</span>)</span><br><span class=\"line\">        func()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inner</span><br><span class=\"line\"><span class=\"meta\">@a</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">b</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;function&quot;</span>)</span><br><span class=\"line\">b()</span><br></pre></td></tr></table></figure>\n<p>那么@a的功能代替了原本<code>b = a(b)</code>，对函数进行修饰。<br>那么这样我们就完成了一个最基本的修饰器</p>\n</div><div class=\"story post-story\"><h2 id=\"参数装饰函数\"><a href=\"#参数装饰函数\" class=\"headerlink\" title=\"参数装饰函数\"></a>参数装饰函数</h2><h2 id=\"待补充\"><a href=\"#待补充\" class=\"headerlink\" title=\"待补充\"></a>待补充</h2><h2 id=\"待排版\"><a href=\"#待排版\" class=\"headerlink\" title=\"待排版\"></a>待排版</h2><p>实际上，只要这个对象使用特殊方法实现了__call__()，那么这个对象就是可以被可调用。 </p>\n\n</div>",
            "tags": [
                "DevLog",
                "Python"
            ]
        },
        {
            "id": "https://nanaeo.cn/2022/08/13/GaussWave/",
            "url": "https://nanaeo.cn/2022/08/13/GaussWave/",
            "title": "高斯滤波",
            "date_published": "2022-08-13T16:00:00.000Z",
            "content_html": "<p>高斯滤波的实现</p>\n<span id=\"more\"></span>\n\n<div class=\"story post-story\"><h2 id=\"本文提示\"><a href=\"#本文提示\" class=\"headerlink\" title=\"本文提示\"></a>本文提示</h2><p><strong>本文仍然在编辑&#x2F;排版中</strong><br>本文提供了相关代码和算法仅为示例学习，并非标准案例，并且OpenCV提供了高斯滤波函数，如果遇到不明白的概念和地方可以参考引用文章理解，也可以尝试在搜索引擎上搜索相关概念和图片示例，由于本站资源原因，暂不提供图片。</p>\n<p>tips: 本文为了方便仅是灰度图片处理<br>如果需要彩色图片应该尝试修改代码三种通道进行分别处理或其它方法。</p>\n</div><div class=\"story post-story\"><h2 id=\"概念理解-部分来自百科等\"><a href=\"#概念理解-部分来自百科等\" class=\"headerlink\" title=\"概念理解(部分来自百科等)\"></a>概念理解(部分来自百科等)</h2><h3 id=\"滤波\"><a href=\"#滤波\" class=\"headerlink\" title=\"滤波\"></a>滤波</h3><p>滤波就对图像像素点及其邻域点的灰度值按照一定的参数规则进行加权平均，可以有效滤去理想图像中叠加的高频噪声。常用的滤波有线性滤波、中值滤波、均值滤波、双边滤波、高斯滤波等。滤波有抑制噪声的作用，但这会使得图像边缘模糊。(摘自别的地方)</p>\n<h3 id=\"低通滤波\"><a href=\"#低通滤波\" class=\"headerlink\" title=\"低通滤波\"></a>低通滤波</h3><p>低通滤波是一种过滤方式，规则为低频信号能正常通过，而超过设定临界值的高频信号则被阻隔、减弱，图像处理领域可用来模糊。</p>\n<h3 id=\"高通滤波\"><a href=\"#高通滤波\" class=\"headerlink\" title=\"高通滤波\"></a>高通滤波</h3><p>高通滤波(high-pass filter) 是一种过滤方式，规则为高频信号能正常通过，而低于设定临界值的低频信号则被阻隔、减弱。但是阻隔、减弱的幅度则会依据不同的频率以及不同的滤波程序(目的)而改变，图像处理领域可用于锐化。</p>\n<h3 id=\"高斯滤波\"><a href=\"#高斯滤波\" class=\"headerlink\" title=\"高斯滤波\"></a>高斯滤波</h3><p>高斯滤波是一种线性平滑滤波，适用于消除高斯噪声，广泛应用于图像处理的减噪过程，对处理呈现正态分布(高斯分布)的噪声(包括图像噪声)效果显著。<br>tips: 常用高斯模糊就是使用高斯滤波完成的， 高斯模糊是低通滤波的一种， 也就是滤波函数是低通高斯函数， 但是高斯滤波是指用高斯函数作为滤波函数， 至于是不是模糊，要看是高斯低通还是高斯高通， 低通就是模糊， 高通就是锐化。</p>\n<h3 id=\"核算子、模板、结构都是一种\"><a href=\"#核算子、模板、结构都是一种\" class=\"headerlink\" title=\"核算子、模板、结构都是一种\"></a>核算子、模板、结构都是一种</h3><p>当我们进行图像处理时时，使用到的权用一个矩阵表示，可以利用该矩阵计算对应像素，同时我们叫这个矩阵为核算子、模板、结构。(示例见前提指明)<br>大小可小可大，并且一般为奇数，<br>Que:核大小为什么是都是类似3×3&#x2F;5×5 奇数呢?<br>其中一个原因是定位中心锚点，偶数是无法确定中心点的。</p>\n<h3 id=\"滤波核\"><a href=\"#滤波核\" class=\"headerlink\" title=\"滤波核\"></a>滤波核</h3><p>当进行滤波时，里面是核的内容是权重并且可以用于处理像素，那么该核称为滤波核。<br>(通俗解释 专业解释 请查询资料)</p>\n<h3 id=\"归一化\"><a href=\"#归一化\" class=\"headerlink\" title=\"归一化\"></a>归一化</h3><p>就是生成核或者说模板加起来的权不为一，这时候我们核内每一个值除以核内总值，就实现了归一化。</p>\n<h3 id=\"卷积核\"><a href=\"#卷积核\" class=\"headerlink\" title=\"卷积核\"></a>卷积核</h3><p>如果一个核被用于卷积那么该核也可以被称为卷积核。(通俗解释 专业解释 请查询资料)</p>\n<h3 id=\"高斯核\"><a href=\"#高斯核\" class=\"headerlink\" title=\"高斯核\"></a>高斯核</h3><p>那么高斯核固然就是高斯分布生成的核了</p>\n</div><div class=\"story post-story\"><h2 id=\"环境与依赖\"><a href=\"#环境与依赖\" class=\"headerlink\" title=\"环境与依赖\"></a>环境与依赖</h2><p>Python        本次使用的编程语言<br>OpenCV        跨平台计算机视觉库<br>Windows11     本文中代码运行系统</p>\n<h3 id=\"OpenCv库安装\"><a href=\"#OpenCv库安装\" class=\"headerlink\" title=\"OpenCv库安装\"></a>OpenCv库安装</h3><p>(清华源 可自行切换)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install opencv-python -i https://pypi.tuna.tsinghua.edu.cn/simple opencv-python</span><br><span class=\"line\">pip install opencv-contrib-python -i https://pypi.tuna.tsinghua.edu.cn/simple opencv-python</span><br></pre></td></tr></table></figure>\n</div><div class=\"story post-story\"><h2 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h2><p>最终滤波核示例 (提示:权请保证和为1 此处已经归一化 但并非真实情况)<br>0.1 0.1 0.2<br>0.1 0.1 0.1<br>0.1 0.1 0.1</p>\n<p>为3×3网格坐标结构<br>该模板大小 3×3</p>\n</div><div class=\"story post-story\"><h2 id=\"算法过程\"><a href=\"#算法过程\" class=\"headerlink\" title=\"算法过程\"></a>算法过程</h2><h3 id=\"高斯滤波实现方法\"><a href=\"#高斯滤波实现方法\" class=\"headerlink\" title=\"高斯滤波实现方法\"></a>高斯滤波实现方法</h3><p>看完以上相信各位并没有很多理解，并不要紧，联系实际我们进一步进行<br>高斯滤波通常情况下有两种实现方式，一是用离散化窗口滑窗卷积， 另一种通过傅里叶变换，其中第一种毕竟常见，可能这时候有人又问了，这又是什么，别急，咱先慢慢来，离散化窗口滑窗卷积其实就是进行有限次的移动核运算区域的卷积运算，那么我们可以开始了。</p>\n<h3 id=\"算法过程-1\"><a href=\"#算法过程-1\" class=\"headerlink\" title=\"算法过程\"></a>算法过程</h3><p>0.图像灰度处理 (为了方便)</p>\n<ol>\n<li>生成滤波核</li>\n<li>进行卷积处理图像</li>\n</ol>\n<h3 id=\"生成滤波核\"><a href=\"#生成滤波核\" class=\"headerlink\" title=\"生成滤波核\"></a>生成滤波核</h3><p><img src=\"https://s2.loli.net/2022/08/14/4dgAQ2RCInSM8m6.gif\" class=\"lazyload\" data-srcset=\"https://s2.loli.net/2022/08/14/4dgAQ2RCInSM8m6.gif\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" alt=\"CodeCogsEqn.gif\"><br>(此处为一维高斯函数)</p>\n<p>sigma 为标准差 图像平滑程度取决于该值<br>我们使用高斯函数进行生成对应滤波核<br>离中心点越远那么边缘值的权值越小，我们依照高斯二维函数就可以生成对应滤波核。<br>代码具体参考如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def GaussKernel(size,k,sigma):</span><br><span class=\"line\">    _t = np.zeros((size,size),np.float32)</span><br><span class=\"line\">    for i in range (size):</span><br><span class=\"line\">        for j in range (size):</span><br><span class=\"line\">            norm = math.pow(i-k,2) + pow(j-k,2)</span><br><span class=\"line\">            _t[i,j] = math.exp(-norm/(2*math.pow(sigma,2)))/2*math.pi*pow(sigma,2)</span><br><span class=\"line\">    sum = np.sum(_t)</span><br><span class=\"line\">    kernel = _t/sum</span><br><span class=\"line\">    return kernel</span><br></pre></td></tr></table></figure>\n<h3 id=\"卷积生成\"><a href=\"#卷积生成\" class=\"headerlink\" title=\"卷积生成\"></a>卷积生成</h3><p>然后我们使用对应的滤波权值进行乘以像素值，就可以生成新值，但是滤波核仅3×3大小，我们在原图像每一个像素点运算一次，即可生成新的图形。<br>运算为: 每个像素点周围点 权×值 的和为中心点新值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def mygaussFilter(img_gray,kernel):</span><br><span class=\"line\">    h,w = img_gray.shape</span><br><span class=\"line\">    k_h,k_w = kernel.shape</span><br><span class=\"line\">    for i in range(int(k_h/2),h-int(k_h/2)):</span><br><span class=\"line\">        for j in range(int(k_h/2),w-int(k_h/2)):</span><br><span class=\"line\">            sum = 0</span><br><span class=\"line\">            for k in range(0,k_h):</span><br><span class=\"line\">                for l in range(0,k_h):</span><br><span class=\"line\">                    sum += img_gray[i-int(k_h/2)+k,j-int(k_h/2)+l]*kernel[k,l]</span><br><span class=\"line\">            img_gray[i,j] = sum</span><br><span class=\"line\">    return img_gray</span><br></pre></td></tr></table></figure>\n</div><div class=\"story post-story\"><h2 id=\"样例代码\"><a href=\"#样例代码\" class=\"headerlink\" title=\"样例代码\"></a>样例代码</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import math</span><br><span class=\"line\">import cv2</span><br><span class=\"line\">import numpy as np</span><br><span class=\"line\">def GaussKernel(size,k,sigma):</span><br><span class=\"line\">    _t = np.zeros((size,size),np.float32)</span><br><span class=\"line\">    for i in range (size):</span><br><span class=\"line\">        for j in range (size):</span><br><span class=\"line\">            norm = math.pow(i-k,2) + pow(j-k,2)</span><br><span class=\"line\">            _t[i,j] = math.exp(-norm/(2*math.pow(sigma,2)))/2*math.pi*pow(sigma,2)</span><br><span class=\"line\">    sum = np.sum(_t)</span><br><span class=\"line\">    kernel = _t/sum</span><br><span class=\"line\">    return kernel</span><br><span class=\"line\"></span><br><span class=\"line\">def mygaussFilter(img_gray,kernel):</span><br><span class=\"line\">    h,w = img_gray.shape</span><br><span class=\"line\">    k_h,k_w = kernel.shape</span><br><span class=\"line\">    for i in range(int(k_h/2),h-int(k_h/2)):</span><br><span class=\"line\">        for j in range(int(k_h/2),w-int(k_h/2)):</span><br><span class=\"line\">            sum = 0</span><br><span class=\"line\">            for k in range(0,k_h):</span><br><span class=\"line\">                for l in range(0,k_h):</span><br><span class=\"line\">                    sum += img_gray[i-int(k_h/2)+k,j-int(k_h/2)+l]*kernel[k,l]</span><br><span class=\"line\">            img_gray[i,j] = sum</span><br><span class=\"line\">    return img_gray</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &#x27;__main__&#x27;:</span><br><span class=\"line\">    img = cv2.imread(&quot;demo.jpg&quot;)</span><br><span class=\"line\">    img_gray = cv2.cvtColor(img,cv2.COLOR_RGB2GRAY)</span><br><span class=\"line\">    img_g = img_gray.copy()</span><br><span class=\"line\">    k=1</span><br><span class=\"line\">    size = 2*k+1</span><br><span class=\"line\">    kernel = gausskernel(size,k,1.5)</span><br><span class=\"line\">    print(kernel)</span><br><span class=\"line\">    img_B,img_G,img_R = cv2.split(img)</span><br><span class=\"line\">    img_gauss_B = mygaussFilter(img_B,kernel)</span><br><span class=\"line\">    img_gauss_G = mygaussFilter(img_G,kernel)</span><br><span class=\"line\">    img_gauss_R = mygaussFilter(img_R,kernel)</span><br><span class=\"line\">    img_gauss = cv2.merge([img_gauss_B,img_gauss_G,img_gauss_R])</span><br><span class=\"line\">    img_comp = np.hstack((img,img_gauss))</span><br><span class=\"line\">    cv2.imshow(&quot;gauss&quot;,img_comp)</span><br><span class=\"line\">    cv2.waitKey(0)</span><br></pre></td></tr></table></figure>\n</div><div class=\"story post-story\"><h2 id=\"直接OpenCV操作-非原理实现方案-使用封装方法\"><a href=\"#直接OpenCV操作-非原理实现方案-使用封装方法\" class=\"headerlink\" title=\"直接OpenCV操作(非原理实现方案 使用封装方法)\"></a>直接OpenCV操作(非原理实现方案 使用封装方法)</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import cv2</span><br><span class=\"line\">Gn=cv2.imread(&quot;Gaussian_noise.jpg&quot;) </span><br><span class=\"line\">Gf=cv2.GaussianBlur(Gn,(3,3),0,0)</span><br><span class=\"line\">cv2.imshow(&quot;噪声图像&quot;,Gn)</span><br><span class=\"line\">cv2.imshow(&quot;滤波图像&quot;,Gf)</span><br><span class=\"line\">cv2.waitKey()</span><br><span class=\"line\">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>\n</div><div class=\"story post-story\"><h2 id=\"Que-边界点的处理\"><a href=\"#Que-边界点的处理\" class=\"headerlink\" title=\"Que: 边界点的处理\"></a>Que: 边界点的处理</h2><p>如果一个点处于边界，周边没有足够的点，怎么办？<br>一个变通方法，就是把已有的点拷贝到另一面的对应位置，模拟出完整的矩阵。<br>当然我们这里很简单，就是进行矩阵补零上去，用零进行模拟完整矩阵。</p>\n</div><div class=\"story post-story\"><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>高斯滤波可以让图像高斯噪声降低，并且平滑图像，并且opencv等库已经提供封装，我们可以很快的使用</p>\n</div><div class=\"story post-story\"><h2 id=\"文章引用\"><a href=\"#文章引用\" class=\"headerlink\" title=\"文章引用\"></a>文章引用</h2><p>高斯滤波<br><a href=\"https://blog.csdn.net/weixin_51571728/article/details/121527964\">https://blog.csdn.net/weixin_51571728/article/details/121527964</a><br>高斯滤波核<br><a href=\"https://blog.csdn.net/qqq777_/article/details/112800310\">https://blog.csdn.net/qqq777_/article/details/112800310</a><br>有关线性滤波、滤波核的基本概念(概念理解)<br><a href=\"https://blog.csdn.net/weixin_42664622/article/details/103672899\">https://blog.csdn.net/weixin_42664622/article/details/103672899</a><br>数字图像处理基础 — 高斯滤波<br><a href=\"https://zhuanlan.zhihu.com/p/82569305\">https://zhuanlan.zhihu.com/p/82569305</a><br>图像滤波原理(不推荐)<br><a href=\"https://view.inews.qq.com/a/20220425A06HHF00\">https://view.inews.qq.com/a/20220425A06HHF00</a></p>\n</div><div class=\"story post-story\"><h2 id=\"提示\"><a href=\"#提示\" class=\"headerlink\" title=\"提示\"></a>提示</h2><p>该文章并不准确，如果有错误请积极指出。</p>\n\n</div>",
            "tags": [
                "DevLog",
                "Gauss"
            ]
        }
    ]
}